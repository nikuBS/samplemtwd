<%- include('../../components/start.component.html', { pageInfo: locals.pageInfo }); %>
<body class="rn">
<div id="productRoaming">
    <div id="gnb">
        <span class="menu">
            <img src="<%= CDN %>/img/product/roam/menu_black.png" alt="컨텍스트 메뉴" width="24" height="24" />
        </span>
        <img class="logo" src="<%= CDN %>/img/product/roam/logo.png" alt="로고" width="94" height="24" />
    </div>
    <div id="background"></div>
    <div id="contents">
        <h2>해외여행 갈 땐</h2>
        <h2 class="colorPoint">T로밍과 함께 !</h2>
        <p class="description">
            T로밍 요금제를 통해 해외에서도 국내처럼 <br />
            자유롭게 baro 통화하세요.
        </p>
        <div class="card">
            <h3>국가별 맞춤 로밍 요금제 추천</h3>
            <p class="description">여행하실 나라를 선택해주세요</p>
            <div id="nations">
                <ul></ul> 
            </div>
            <p class="description">찾으시는 나라가 없으신가요?</p>
            <form action="#" onsubmit="console.log('nation-search'); return false;">
            <div class="field-container">
                <input type="text" placeholder="원하시는 국가 명을 입력해주세요" id="nation-search" />
                <img src="<%= CDN %>/img/product/roam/ico_search_a.png" width="21" height="21" alt="Search" />
            </div>
            </form>
            <div class="link">
                <a href="#" onclick="openNationsPopup(); return false;">전체 국가보기</a>
            </div>
        </div>
        <div class="banner">
            <!-- TODO: 배너 API 연동 -->
            <a href="/product/roaming/info/barocall">
                <img src="<%= CDN %>/img/product/roam/banner_01.png" alt="광고배너 Baro 통화" />
            </a>
        </div>
        <div class="card">
            <h3>로밍 요금제 한눈에 보기</h3>
            <div id="tariffs">
            </div>
        </div>
        <div class="card no-padding">
            <a href="/product/roaming/coupon">
                <div class="menu-link border-bottom">
                    <img class="icon" src="<%= CDN %>/img/product/roam/ico_coupon.png" width="32" />
                    <span>로밍 카드/쿠폰</span>
                    <img class="arrow" src="<%= CDN %>/img/product/roam/ico_arrow.png" width="13" />
                </div>
            </a>
            <a href="/product/roaming/fi/guide">
                <div class="menu-link">
                    <img class="icon" src="<%= CDN %>/img/product/roam/ico_barobox.png" width="32" />
                    <span>baro Box 대여</span>
                    <img class="arrow" src="<%= CDN %>/img/product/roam/ico_arrow.png" width="13" />
                </div>
            </a>
        </div>
    </div>
    <!--
        TODO:
        출국 전 알아두면 좋은 정보
        로밍 중 휴대폰 분실 안내
    -->
</div>
<div id="nationsPopup" class="popup">
    <div class="header">
        <h1>로밍 가능한 전체 국가</h1>
        <div class="close" onclick="closePopup()">
            <svg width="20" height="20" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                <g fill="#000">
                    <rect height="3" rx="1.5" transform="matrix(.70710678 .70710678 -.70710678 .70710678 20.353553 -8.137825)" width="42" x="-1" y="19"/>
                    <rect height="3" rx="1.5" transform="matrix(-.70710678 .70710678 .70710678 .70710678 19.646447 -8.137825)" width="42" x="-1" y="19"/>
                </g>
            </svg>
        </div>
    </div>
    <div class="menu">
        <ul>
            <li id="major">주요국가</li>
            <li id="europe">유럽</li>
            <li id="asia">아시아</li>
            <li id="america">미주</li>
            <li id="oceania">오세아니아</li>
            <li id="middleeast">중동</li>
            <li id="africa">아프리카</li>
        </ul>
    </div>
    <div class="content">
        <ul>

        </ul>
    </div>
</div>
<div id="schedulePopup" class="popup">
    <div class="header">
        <img src="<%= CDN %>/img/product/roam/img_nation_m_01.png" width="100%" />
        <div class="summary">
            <h1>언제 떠나세요?</h1>
            <div class="date">
                <h2>가는날</h2>
                <!-- TODO: 2020.07.15 -->
                <h3 id="date-depart">2020.08.19</h3>
            </div>
            <div class="date">
                <h2>오는날</h2>
                <h3 id="date-arrive">2020.08.23</h3>
            </div>
        </div>
        <div class="close" onclick="closePopup()">
            <svg width="20" height="20" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                <g fill="#fff">
                    <rect height="3" rx="1.5" transform="matrix(.70710678 .70710678 -.70710678 .70710678 20.353553 -8.137825)" width="42" x="-1" y="19"/>
                    <rect height="3" rx="1.5" transform="matrix(-.70710678 .70710678 .70710678 .70710678 19.646447 -8.137825)" width="42" x="-1" y="19"/>
                </g>
            </svg>
        </div>
    </div>
    <div class="content">
        <div id="calendar">

        </div>
    </div>
    <div class="footer" onclick="closePopup();">
        추천 요금제 확인
    </div>
</div>
<script type="text/x-handlebars-template" id="tpl-nation-card">
    <li onclick="openSchedulePopup('{{ code }}');">
        <img src="{{ imageUrl }}" width="{{ width }}">
        <span>{{ name }}</span>
    </li>
</script>
<script type="text/x-handlebars-template" id="tpl-tariff-card">
    <div class="tariff">
        <img src="<%= CDN %>/img/product/roam/{{ icon }}" alt="product-icon" /> 
        <h4>{{ title }}</h4>
        <h5>{{ subtitle }}</h5>
    </div>
</script>
</body>
<% include ../../components/javascript.component.html %>

<script>
  $(document).ready(function () {
    new Tw.NextRoaming($('#productRoaming'), '<%= pageInfo.menuId %>')
    fillRecommendedNations();
    fillTariffs();
    prepareNations();
    $('#nation-search').autocomplete({
      source: allNations,
      delay: 100,
      minLength: 1,
    });
    setupNationsPopup();
    // openSchedulePopup('japan');
  });
  function prepareNations() {
    let all = [];
    const categories = Object.keys(nations);
    for (let i=0; i<categories.length; i+=1) {
      let category = categories[i];
      if (category === 'major')
        continue;
      const items = nations[category].split(', ');
      all = all.concat(items);
    }
    all.sort();
    allNations = all;
  }
  function setupNationsPopup() {
    const menuItems = $('#nationsPopup .menu li');
    for (var i=0; i<menuItems.length; i++) {
      menuItems[i].onclick = function (event) {
        onClickNationGroup(event.target)
      };
    }
  }
  function onClickNationGroup(menu) {
    $('#nationsPopup .menu li').removeClass('active');
    menu.className = 'active';
    const selectedNations = nations[menu.id].split(', ')
    const targetList = $('#nationsPopup .content ul')
    targetList.html('');
    for (var nation of selectedNations) {
      var li = document.createElement('li');
      li.innerText = nation;
      targetList.append(li);
    }
  }
  function fillRecommendedNations() {
    const GAP = 6;
    const COLUMN = 3;
    const container = document.getElementById('nations');
    const nationWidth = Math.floor((container.clientWidth - GAP * COLUMN) / COLUMN);
    const ul = document.querySelector('#nations ul');
    const template = Handlebars.compile($('#tpl-nation-card').html());
    for (let i = 0; i < recommendedNationList.length; i++) {
      const item = recommendedNationList[i];
      const li = template({
        width: nationWidth - GAP,
        name: item.name,
        code: item.code,
        imageUrl: item.url,
      });
      ul.innerHTML += li;
    }
  }
  function fillTariffs() {
    const template = Handlebars.compile($('#tpl-tariff-card').html());
    const container = document.getElementById('tariffs');
    container.innerHTML = '';
    for (var i=0; i<tariffList.length; i++) {
      const item = tariffList[i];
      container.innerHTML += template({
        icon: item.icon,
        title: item.name,
        subtitle: item.description,
      });
    }
  }
  function openNationsPopup() {
    onClickNationGroup(document.getElementById('major'));
    $('#productRoaming').css('display', 'none');
    $('#nationsPopup').css('display', 'block');
  }
  function openSchedulePopup(code) {
    $('#schedulePopup').css('display', 'block');
    $('#productRoaming').css('display', 'none');

    $('div#calendar').daterangepicker({
      element: $('div#calendar'),
      parentEl: 'div#calendar',
      minDate: '2020-08-19',
    });
  }
  function closePopup() {
    $('#nationsPopup').css('display', 'none');
    $('#schedulePopup').css('display', 'none');
    $('#productRoaming').css('display', 'block');
  }

  const tariffList = [
    {url: '', name: 'baro 요금제', description: '전세계 주요국가에서', icon: 'icon_planet.png'},
    {url: '', name: 'One Pass', description: '출장을 자주 간다면', icon: 'icon_onepass.png'},
    {url: '', name: 'One Pass VIP', description: '해외에서도 데이터를 무제한으로', icon: 'icon_vip.png'},
  ];

  const recommendedNationList = [
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_01.png',
      'name': '중국',
      'code': 'china',
    },
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_02.png',
      'name': '일본',
      'code': 'japan',
    },
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_03.png',
      'name': '베트남',
      'code': 'vietnam',
    },
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_04.png',
      'name': '필리핀',
      'code': 'philippines',
    },
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_05.png',
      'name': '미국',
      'code': 'america',
    },
    {
      'url': '<%= CDN %>/img/product/roam/img_nation_s_06.png',
      'name': '이탈리아',
      'code': 'italy',
    },
  ];

  const nations = {
    'major': '중국, 일본, 베트남, 필리핀, 미국, 이탈리아',
    'europe': '건지섬, 그리스, 네덜란드, 노르웨이, 니제르, 덴마크, 독일, 라트비아, 러시아, 루마니아, 룩셈부르크, 리투아니아, ' +
        '리히텐슈타인, 마케도니아, 맨섬, 모나코, 몬테네그로, 몰타, 바티칸, 벨기에, 벨라루스, 보스니아헤르체고비나, 부르키나파소, ' +
        '불가리아, 산마리노, 세르비아, 스발바르 제도, 스웨덴, 스위스, 스페인, 슬로바키아, 슬로베니아, 아르메니아, 아이슬란드, ' +
        '아일랜드, 알바니아, 에스토니아, 에티오피아, 영국, 오스트리아, 올란드제도, 우크라이나, 이탈리아, 저지섬, 조지아(그루지야), ' +
        '지브롤터, 체코, 크로아티아, 키프로스, 터키, 페로제도, 포르투갈, 폴란드, 프랑스, 핀란드, 헝가리',
    'asia': '네팔, 대만, 라오스, 마카오, 말레이시아, 몽골, 미얀마, 방글라데시, 베트남, 부탄, 브루나이, 스리랑카, ' +
        '싱가포르, 아제르바이젠, 우즈베키스탄, 인도, 인도네시아, 일본, 중국, 카자흐스탄, 캄보디아, 키르기즈스탄, 태국, 파키스탄, 필리핀, 홍콩',
    'america': '과테말라, 니카라과, 도미니카 공화국, 멕시코, 미국, 버진아일랜드, 브라질, 아르헨티나, 에콰도르, 엘살바도르, ' +
        '우루과이, 칠레, 캐나다, 코스타리카, 콜롬비아, 파나마, 페루, 푸에르토리코',
    'oceania': '뉴질랜드, 호주',
    'middleeast': '아랍에미리트(UAE), 이스라엘, 카타르',
    'africa': '가봉, 니제르, 르완다, 마다가스카르, 모리셔스, 알제리, 우간다, 이집트, 잠비아, 케냐, 콩고 민주공화국, 차드, 탄자니아',
  };
  var allNations = [];

</script>

<script type="text/javascript">
  /**
   * @version: 3.1
   * @author: Dan Grossman http://www.dangrossman.info/
   * @copyright: Copyright (c) 2012-2019 Dan Grossman. All rights reserved.
   * @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
   * @website: http://www.daterangepicker.com/
   */
// Following the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
      // AMD. Make globaly available as well
      define(['moment', 'jquery'], function (moment, jquery) {
        if (!jquery.fn) jquery.fn = {}; // webpack server rendering
        if (typeof moment !== 'function' && moment.hasOwnProperty('default')) moment = moment['default']
        return factory(moment, jquery);
      });
    } else if (typeof module === 'object' && module.exports) {
      // Node / Browserify
      //isomorphic issue
      var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
      if (!jQuery) {
        jQuery = require('jquery');
        if (!jQuery.fn) jQuery.fn = {};
      }
      var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
      module.exports = factory(moment, jQuery);
    } else {
      // Browser globals
      root.daterangepicker = factory(root.moment, root.jQuery);
    }
  }(typeof window !== 'undefined' ? window : this, function(moment, $) {
    var DateRangePicker = function(element, options, cb) {

      //default settings for options
      this.parentEl = 'body';
      this.element = $(element);
      this.startDate = moment().startOf('day');
      this.endDate = moment().endOf('day');
      this.minDate = false;
      this.maxDate = false;
      this.maxSpan = false;
      this.autoApply = false;
      this.singleDatePicker = false;
      this.minYear = moment().subtract(100, 'year').format('YYYY');
      this.maxYear = moment().add(100, 'year').format('YYYY');
      this.showWeekNumbers = false;
      this.showISOWeekNumbers = false;
      this.showCustomRangeLabel = true;
      this.linkedCalendars = true;
      this.autoUpdateInput = true;
      this.alwaysShowCalendars = false;
      this.ranges = {};

      this.opens = 'right';
      if (this.element.hasClass('pull-right'))
        this.opens = 'left';

      this.drops = 'down';
      if (this.element.hasClass('dropup'))
        this.drops = 'up';

      this.buttonClasses = 'btn btn-sm';
      this.applyButtonClasses = 'btn-primary';
      this.cancelButtonClasses = 'btn-default';

      this.locale = {
        direction: 'ltr',
        format: moment.localeData().longDateFormat('L'),
        separator: ' - ',
        applyLabel: 'Apply',
        cancelLabel: 'Cancel',
        weekLabel: 'W',
        customRangeLabel: 'Custom Range',
        daysOfWeek: moment.weekdaysMin(),
        monthNames: moment.monthsShort(),
        firstDay: moment.localeData().firstDayOfWeek()
      };

      this.callback = function() { };

      //some state information
      this.isShowing = false;
      this.leftCalendar = {};
      this.rightCalendar = {};

      //custom options from user
      if (typeof options !== 'object' || options === null)
        options = {};

      //allow setting options with data attributes
      //data-api options will be overwritten with custom javascript options
      options = $.extend(this.element.data(), options);

      //html template for the picker UI
      if (typeof options.template !== 'string' && !(options.template instanceof $))
        options.template =
          '<div class="daterangepicker">' +
          '<div class="ranges"></div>' +
          '<div class="drp-calendar left">' +
          '<div class="calendar-table"></div>' +
          '</div>' +
          '<div class="drp-calendar right">' +
          '<div class="calendar-table"></div>' +
          '</div>' +
          '</div>';

      this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
      this.container = $(options.template).appendTo(this.parentEl);

      //
      // handle all the possible options overriding defaults
      //

      this.container.addClass(this.locale.direction);

      if (typeof options.startDate === 'string')
        this.startDate = moment(options.startDate, this.locale.format);

      if (typeof options.endDate === 'string')
        this.endDate = moment(options.endDate, this.locale.format);

      if (typeof options.minDate === 'string')
        this.minDate = moment(options.minDate, this.locale.format);

      if (typeof options.maxDate === 'string')
        this.maxDate = moment(options.maxDate, this.locale.format);

      if (typeof options.startDate === 'object')
        this.startDate = moment(options.startDate);

      if (typeof options.endDate === 'object')
        this.endDate = moment(options.endDate);

      if (typeof options.minDate === 'object')
        this.minDate = moment(options.minDate);

      if (typeof options.maxDate === 'object')
        this.maxDate = moment(options.maxDate);

      // sanity check for bad options
      if (this.minDate && this.startDate.isBefore(this.minDate))
        this.startDate = this.minDate.clone();

      // sanity check for bad options
      if (this.maxDate && this.endDate.isAfter(this.maxDate))
        this.endDate = this.maxDate.clone();

      if (typeof options.applyButtonClasses === 'string')
        this.applyButtonClasses = options.applyButtonClasses;

      if (typeof options.applyClass === 'string') //backwards compat
        this.applyButtonClasses = options.applyClass;

      if (typeof options.cancelButtonClasses === 'string')
        this.cancelButtonClasses = options.cancelButtonClasses;

      if (typeof options.cancelClass === 'string') //backwards compat
        this.cancelButtonClasses = options.cancelClass;

      if (typeof options.maxSpan === 'object')
        this.maxSpan = options.maxSpan;

      if (typeof options.dateLimit === 'object') //backwards compat
        this.maxSpan = options.dateLimit;

      if (typeof options.opens === 'string')
        this.opens = options.opens;

      if (typeof options.drops === 'string')
        this.drops = options.drops;

      if (typeof options.showWeekNumbers === 'boolean')
        this.showWeekNumbers = options.showWeekNumbers;

      if (typeof options.showISOWeekNumbers === 'boolean')
        this.showISOWeekNumbers = options.showISOWeekNumbers;

      if (typeof options.buttonClasses === 'string')
        this.buttonClasses = options.buttonClasses;

      if (typeof options.buttonClasses === 'object')
        this.buttonClasses = options.buttonClasses.join(' ');

      if (typeof options.minYear === 'number')
        this.minYear = options.minYear;

      if (typeof options.maxYear === 'number')
        this.maxYear = options.maxYear;

      if (typeof options.showCustomRangeLabel === 'boolean')
        this.showCustomRangeLabel = options.showCustomRangeLabel;

      if (typeof options.singleDatePicker === 'boolean') {
        this.singleDatePicker = options.singleDatePicker;
        if (this.singleDatePicker)
          this.endDate = this.startDate.clone();
      }

      if (typeof options.autoApply === 'boolean')
        this.autoApply = options.autoApply;

      if (typeof options.autoUpdateInput === 'boolean')
        this.autoUpdateInput = options.autoUpdateInput;

      if (typeof options.linkedCalendars === 'boolean')
        this.linkedCalendars = options.linkedCalendars;

      if (typeof options.isInvalidDate === 'function')
        this.isInvalidDate = options.isInvalidDate;

      if (typeof options.isCustomDate === 'function')
        this.isCustomDate = options.isCustomDate;

      if (typeof options.alwaysShowCalendars === 'boolean')
        this.alwaysShowCalendars = options.alwaysShowCalendars;

      // update day names order to firstDay
      if (this.locale.firstDay != 0) {
        var iterator = this.locale.firstDay;
        while (iterator > 0) {
          this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
          iterator--;
        }
      }

      var start, end, range;

      //if no start/end dates set, check if an input element contains initial values
      if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
        if ($(this.element).is(':text')) {
          var val = $(this.element).val(),
            split = val.split(this.locale.separator);

          start = end = null;

          if (split.length == 2) {
            start = moment(split[0], this.locale.format);
            end = moment(split[1], this.locale.format);
          } else if (this.singleDatePicker && val !== "") {
            start = moment(val, this.locale.format);
            end = moment(val, this.locale.format);
          }
          if (start !== null && end !== null) {
            this.setStartDate(start);
            this.setEndDate(end);
          }
        }
      }

      if (typeof options.ranges === 'object') {
        for (range in options.ranges) {

          if (typeof options.ranges[range][0] === 'string')
            start = moment(options.ranges[range][0], this.locale.format);
          else
            start = moment(options.ranges[range][0]);

          if (typeof options.ranges[range][1] === 'string')
            end = moment(options.ranges[range][1], this.locale.format);
          else
            end = moment(options.ranges[range][1]);

          // If the start or end date exceed those allowed by the minDate or maxSpan
          // options, shorten the range to the allowable period.
          if (this.minDate && start.isBefore(this.minDate))
            start = this.minDate.clone();

          var maxDate = this.maxDate;
          if (this.maxSpan && maxDate && start.clone().add(this.maxSpan).isAfter(maxDate))
            maxDate = start.clone().add(this.maxSpan);
          if (maxDate && end.isAfter(maxDate))
            end = maxDate.clone();

          // If the end of the range is before the minimum or the start of the range is
          // after the maximum, don't display this range option at all.
          if ((this.minDate && end.isBefore(this.minDate, 'day'))
            || (maxDate && start.isAfter(maxDate, 'day')))
            continue;

          //Support unicode chars in the range names.
          var elem = document.createElement('textarea');
          elem.innerHTML = range;
          var rangeHtml = elem.value;

          this.ranges[rangeHtml] = [start, end];
        }

        var list = '<ul>';
        for (range in this.ranges) {
          list += '<li data-range-key="' + range + '">' + range + '</li>';
        }
        if (this.showCustomRangeLabel) {
          list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
        }
        list += '</ul>';
        this.container.find('.ranges').prepend(list);
      }

      if (typeof cb === 'function') {
        this.callback = cb;
      }

      this.startDate = this.startDate.startOf('day');
      this.endDate = this.endDate.endOf('day');

      if (this.autoApply) {
        this.container.addClass('auto-apply');
      }

      if (typeof options.ranges === 'object')
        this.container.addClass('show-ranges');

      if (this.singleDatePicker) {
        this.container.addClass('single');
        this.container.find('.drp-calendar.left').addClass('single');
        this.container.find('.drp-calendar.left').show();
        this.container.find('.drp-calendar.right').hide();
        if (this.autoApply) {
          this.container.addClass('auto-apply');
        }
      }

      if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
        this.container.addClass('show-calendar');
      }

      this.container.addClass('opens' + this.opens);

      //apply CSS classes and labels to buttons
      this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
      if (this.applyButtonClasses.length)
        this.container.find('.applyBtn').addClass(this.applyButtonClasses);
      if (this.cancelButtonClasses.length)
        this.container.find('.cancelBtn').addClass(this.cancelButtonClasses);
      this.container.find('.applyBtn').html(this.locale.applyLabel);
      this.container.find('.cancelBtn').html(this.locale.cancelLabel);

      //
      // event listeners
      //

      this.container.find('.drp-calendar')
        .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
        .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
        .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
        .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
        .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
        .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))

      this.container.find('.ranges')
        .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this));

      this.container.find('.drp-buttons')
        .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
        .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this));

      if (this.element.is('input') || this.element.is('button')) {
        this.element.on({
          'click.daterangepicker': $.proxy(this.show, this),
          'focus.daterangepicker': $.proxy(this.show, this),
          'keyup.daterangepicker': $.proxy(this.elementChanged, this),
        });
      }
      //
      // if attached to a text input, set the initial value
      //

      this.updateElement();

    };

    DateRangePicker.prototype = {

      constructor: DateRangePicker,

      setStartDate: function(startDate) {
        if (typeof startDate === 'string')
          this.startDate = moment(startDate, this.locale.format);

        if (typeof startDate === 'object')
          this.startDate = moment(startDate);

        this.startDate = this.startDate.startOf('day');
        if (this.minDate && this.startDate.isBefore(this.minDate)) {
          this.startDate = this.minDate.clone();
        }
        if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
          this.startDate = this.maxDate.clone();
        }

        if (!this.isShowing)
          this.updateElement();

        this.updateMonthsInView();
      },

      setEndDate: function(endDate) {
        if (typeof endDate === 'string')
          this.endDate = moment(endDate, this.locale.format);

        if (typeof endDate === 'object')
          this.endDate = moment(endDate);

        this.endDate = this.endDate.endOf('day');
        if (this.endDate.isBefore(this.startDate))
          this.endDate = this.startDate.clone();

        if (this.maxDate && this.endDate.isAfter(this.maxDate))
          this.endDate = this.maxDate.clone();

        if (this.maxSpan && this.startDate.clone().add(this.maxSpan).isBefore(this.endDate))
          this.endDate = this.startDate.clone().add(this.maxSpan);

        this.previousRightTime = this.endDate.clone();

        this.container.find('.drp-selected').html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));

        if (!this.isShowing)
          this.updateElement();

        this.updateMonthsInView();
      },

      isInvalidDate: function() {
        return false;
      },

      isCustomDate: function() {
        return false;
      },

      updateView: function() {
        if (this.endDate)
          this.container.find('.drp-selected').html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
        this.updateMonthsInView();
        this.updateCalendars();
        this.updateFormInputs();
      },

      updateMonthsInView: function() {
        if (this.endDate) {

          //if both dates are visible already, do nothing
          if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
            (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
            &&
            (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
          ) {
            return;
          }

          this.leftCalendar.month = this.startDate.clone().date(2);
          if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
            this.rightCalendar.month = this.endDate.clone().date(2);
          } else {
            this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
          }

        } else {
          if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
            this.leftCalendar.month = this.startDate.clone().date(2);
            this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
          }
        }
        if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
          this.rightCalendar.month = this.maxDate.clone().date(2);
          this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
        }
      },

      updateCalendars: function() {
        this.renderCalendar('left');
        this.renderCalendar('right');

        //highlight any predefined range matching the current start and end dates
        this.container.find('.ranges li').removeClass('active');
        if (this.endDate == null) return;

        this.calculateChosenLabel();
      },

      renderCalendar: function(side) {

        //
        // Build the matrix of dates that will populate the calendar
        //

        var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
        var month = calendar.month.month();
        var year = calendar.month.year();
        var hour = calendar.month.hour();
        var minute = calendar.month.minute();
        var second = calendar.month.second();
        var daysInMonth = moment([year, month]).daysInMonth();
        var firstDay = moment([year, month, 1]);
        var lastDay = moment([year, month, daysInMonth]);
        var lastMonth = moment(firstDay).subtract(1, 'month').month();
        var lastYear = moment(firstDay).subtract(1, 'month').year();
        var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
        var dayOfWeek = firstDay.day();

        //initialize a 6 rows x 7 columns array for the calendar
        var calendar = [];
        calendar.firstDay = firstDay;
        calendar.lastDay = lastDay;

        for (var i = 0; i < 6; i++) {
          calendar[i] = [];
        }

        //populate the calendar with date objects
        var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
        if (startDay > daysInLastMonth)
          startDay -= 7;

        if (dayOfWeek == this.locale.firstDay)
          startDay = daysInLastMonth - 6;

        var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

        var col, row;
        for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
          if (i > 0 && col % 7 === 0) {
            col = 0;
            row++;
          }
          calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
          curDate.hour(12);

          if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
            calendar[row][col] = this.minDate.clone();
          }

          if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
            calendar[row][col] = this.maxDate.clone();
          }

        }

        //make the calendar object available to hoverDate/clickDate
        if (side == 'left') {
          this.leftCalendar.calendar = calendar;
        } else {
          this.rightCalendar.calendar = calendar;
        }

        //
        // Display the calendar
        //

        var minDate = side == 'left' ? this.minDate : this.startDate;
        var maxDate = this.maxDate;
        var selected = side == 'left' ? this.startDate : this.endDate;
        var arrow = this.locale.direction == 'ltr' ? {left: 'chevron-left', right: 'chevron-right'} : {left: 'chevron-right', right: 'chevron-left'};

        var html = '<table class="table-condensed">';
        html += '<thead>';
        html += '<tr>';

        // add empty cell for week number
        if (this.showWeekNumbers || this.showISOWeekNumbers)
          html += '<th></th>';

        if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
          html += '<th class="prev available"><span></span></th>';
        } else {
          html += '<th></th>';
        }

        var dateHtml = calendar[1][1].format("YYYY") + '년 ' + this.locale.monthNames[calendar[1][1].month()]

        html += '<th colspan="5" class="month">' + dateHtml + '</th>';
        if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
          html += '<th class="next available"><span></span></th>';
        } else {
          html += '<th></th>';
        }

        html += '</tr>';
        html += '<tr>';

        // add week number label
        if (this.showWeekNumbers || this.showISOWeekNumbers)
          html += '<th class="week">' + this.locale.weekLabel + '</th>';

        $.each(this.locale.daysOfWeek, function(index, dayOfWeek) {
          html += '<th>' + dayOfWeek + '</th>';
        });

        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';

        //adjust maxDate to reflect the maxSpan setting in order to
        //grey out end dates beyond the maxSpan
        if (this.endDate == null && this.maxSpan) {
          var maxLimit = this.startDate.clone().add(this.maxSpan).endOf('day');
          if (!maxDate || maxLimit.isBefore(maxDate)) {
            maxDate = maxLimit;
          }
        }

        for (var row = 0; row < 6; row++) {
          html += '<tr>';

          // add week number
          if (this.showWeekNumbers)
            html += '<td class="week">' + calendar[row][0].week() + '</td>';
          else if (this.showISOWeekNumbers)
            html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

          for (var col = 0; col < 7; col++) {

            var classes = [];

            //highlight today's date
            if (calendar[row][col].isSame(new Date(), "day"))
              classes.push('today');

            //highlight weekends
            if (calendar[row][col].isoWeekday() > 5)
              classes.push('weekend');

            //grey out the dates in other months displayed at beginning and end of this calendar
            if (calendar[row][col].month() != calendar[1][1].month())
              classes.push('off', 'ends');

            //don't allow selection of dates before the minimum date
            if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
              classes.push('off', 'disabled');

            //don't allow selection of dates after the maximum date
            if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
              classes.push('off', 'disabled');

            //don't allow selection of date if a custom function decides it's invalid
            if (this.isInvalidDate(calendar[row][col]))
              classes.push('off', 'disabled');

            //highlight the currently selected start date
            if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
              classes.push('active', 'start-date');

            //highlight the currently selected end date
            if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
              classes.push('active', 'end-date');

            //highlight dates in-between the selected dates
            if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
              classes.push('in-range');

            //apply custom classes for this date
            var isCustom = this.isCustomDate(calendar[row][col]);
            if (isCustom !== false) {
              if (typeof isCustom === 'string')
                classes.push(isCustom);
              else
                Array.prototype.push.apply(classes, isCustom);
            }

            var cname = '', disabled = false;
            for (var i = 0; i < classes.length; i++) {
              cname += classes[i] + ' ';
              if (classes[i] == 'disabled')
                disabled = true;
            }
            if (!disabled)
              cname += 'available';

            html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

          }
          html += '</tr>';
        }

        html += '</tbody>';
        html += '</table>';

        this.container.find('.drp-calendar.' + side + ' .calendar-table').html(html);
      },

      updateFormInputs: function() {

        if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
          this.container.find('button.applyBtn').prop('disabled', false);
        } else {
          this.container.find('button.applyBtn').prop('disabled', true);
        }

      },

      move: function() {
        var parentOffset = { top: 0, left: 0 },
          containerTop,
          drops = this.drops;

        var parentRightEdge = $(window).width();
        if (!this.parentEl.is('body')) {
          parentOffset = {
            top: this.parentEl.offset().top - this.parentEl.scrollTop(),
            left: this.parentEl.offset().left - this.parentEl.scrollLeft()
          };
          parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
        }

        switch (drops) {
          case 'auto':
            containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            if (containerTop + this.container.outerHeight() >= this.parentEl[0].scrollHeight) {
              containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
              drops = 'up';
            }
            break;
          case 'up':
            containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
            break;
          default:
            containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            break;
        }

        // Force the container to it's actual width
        this.container.css({
          top: 0,
          left: 0,
          right: 'auto'
        });
        var containerWidth = this.container.outerWidth();

        this.container.toggleClass('drop-up', drops == 'up');

        if (this.opens == 'left') {
          var containerRight = parentRightEdge - this.element.offset().left - this.element.outerWidth();
          if (containerWidth + containerRight > $(window).width()) {
            this.container.css({
              top: containerTop,
              right: 'auto',
              left: 9
            });
          } else {
            this.container.css({
              top: containerTop,
              right: containerRight,
              left: 'auto'
            });
          }
        } else if (this.opens == 'center') {
          var containerLeft = this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
            - containerWidth / 2;
          if (containerLeft < 0) {
            this.container.css({
              top: containerTop,
              right: 'auto',
              left: 9
            });
          } else if (containerLeft + containerWidth > $(window).width()) {
            this.container.css({
              top: containerTop,
              left: 'auto',
              right: 0
            });
          } else {
            this.container.css({
              top: containerTop,
              left: containerLeft,
              right: 'auto'
            });
          }
        } else {
          var containerLeft = this.element.offset().left - parentOffset.left;
          if (containerLeft + containerWidth > $(window).width()) {
            this.container.css({
              top: containerTop,
              left: 'auto',
              right: 0
            });
          } else {
            this.container.css({
              top: containerTop,
              left: containerLeft,
              right: 'auto'
            });
          }
        }
      },

      show: function(e) {
        if (this.isShowing) return;

        // Reposition the picker if the window is resized while it's open
        $(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));

        this.oldStartDate = this.startDate.clone();
        this.oldEndDate = this.endDate.clone();
        this.previousRightTime = this.endDate.clone();

        this.updateView();
        this.container.show();
        this.move();
        this.element.trigger('show.daterangepicker', this);
        this.isShowing = true;
      },

      hide: function(e) {
        throw new Error('*hide*');
        if (!this.isShowing) return;

        //incomplete date selection, revert to last values
        if (!this.endDate) {
          this.startDate = this.oldStartDate.clone();
          this.endDate = this.oldEndDate.clone();
        }

        //if a new date range was selected, invoke the user callback function
        if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
          this.callback(this.startDate.clone(), this.endDate.clone(), this.chosenLabel);

        //if picker is attached to a text input, update it
        this.updateElement();

        $(document).off('.daterangepicker');
        $(window).off('.daterangepicker');
        this.container.hide();
        this.element.trigger('hide.daterangepicker', this);
        this.isShowing = false;
      },

      showCalendars: function() {
        this.container.addClass('show-calendar');
        this.move();
        this.element.trigger('showCalendar.daterangepicker', this);
      },

      hideCalendars: function() {
        this.container.removeClass('show-calendar');
        this.element.trigger('hideCalendar.daterangepicker', this);
      },

      clickRange: function(e) {
        var label = e.target.getAttribute('data-range-key');
        this.chosenLabel = label;
        if (label == this.locale.customRangeLabel) {
          this.showCalendars();
        } else {
          var dates = this.ranges[label];
          this.startDate = dates[0];
          this.endDate = dates[1];

          this.startDate.startOf('day');
          this.endDate.endOf('day');

          if (!this.alwaysShowCalendars)
            this.hideCalendars();
          this.clickApply();
        }
      },

      clickPrev: function(e) {
        var cal = $(e.target).parents('.drp-calendar');
        if (cal.hasClass('left')) {
          this.leftCalendar.month.subtract(1, 'month');
          if (this.linkedCalendars)
            this.rightCalendar.month.subtract(1, 'month');
        } else {
          this.rightCalendar.month.subtract(1, 'month');
        }
        this.updateCalendars();
      },

      clickNext: function(e) {
        var cal = $(e.target).parents('.drp-calendar');
        if (cal.hasClass('left')) {
          this.leftCalendar.month.add(1, 'month');
        } else {
          this.rightCalendar.month.add(1, 'month');
          if (this.linkedCalendars)
            this.leftCalendar.month.add(1, 'month');
        }
        this.updateCalendars();
      },

      hoverDate: function(e) {

        //ignore dates that can't be selected
        if (!$(e.target).hasClass('available')) return;

        var title = $(e.target).attr('data-title');
        var row = title.substr(1, 1);
        var col = title.substr(3, 1);
        var cal = $(e.target).parents('.drp-calendar');
        var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

        //highlight the dates between the start date and the date being hovered as a potential end date
        var leftCalendar = this.leftCalendar;
        var rightCalendar = this.rightCalendar;
        var startDate = this.startDate;
        if (!this.endDate) {
          this.container.find('.drp-calendar tbody td').each(function(index, el) {

            //skip week numbers, only look at dates
            if ($(el).hasClass('week')) return;

            var title = $(el).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(el).parents('.drp-calendar');
            var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

            if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
              $(el).addClass('in-range');
            } else {
              $(el).removeClass('in-range');
            }

          });
        }

      },

      clickDate: function(e) {

        if (!$(e.target).hasClass('available')) return;

        var title = $(e.target).attr('data-title');
        var row = title.substr(1, 1);
        var col = title.substr(3, 1);
        var cal = $(e.target).parents('.drp-calendar');
        var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

        //
        // this function needs to do a few things:
        // * alternate between selecting a start and end date for the range,
        // * if autoapply is enabled, and an end date was chosen, apply the selection
        // * if single date picker mode, apply the selection immediately
        // * if one of the inputs above the calendars was focused, cancel that manual input
        //

        if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
          this.endDate = null;
          this.setStartDate(date.clone());
        } else if (!this.endDate && date.isBefore(this.startDate)) {
          this.setEndDate(this.startDate.clone());
        } else { // picking end
          this.setEndDate(date.clone());
          if (this.autoApply) {
            this.calculateChosenLabel();
            this.clickApply();
          }
        }

        if (this.singleDatePicker) {
          this.setEndDate(this.startDate);
          if (this.autoApply)
            this.clickApply();
        }

        this.updateView();
        e.stopPropagation();

      },

      calculateChosenLabel: function () {
        var customRange = true;
        var i = 0;
        for (var range in this.ranges) {
          if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
            customRange = false;
            this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').attr('data-range-key');
            break;
          }
          i++;
        }
        if (customRange) {
          if (this.showCustomRangeLabel) {
            this.chosenLabel = this.container.find('.ranges li:last').addClass('active').attr('data-range-key');
          } else {
            this.chosenLabel = null;
          }
          this.showCalendars();
        }
      },

      clickApply: function(e) {
        this.hide();
        this.element.trigger('apply.daterangepicker', this);
      },

      clickCancel: function(e) {
        this.startDate = this.oldStartDate;
        this.endDate = this.oldEndDate;
        this.hide();
        this.element.trigger('cancel.daterangepicker', this);
      },

      monthOrYearChanged: function(e) {
        var isLeft = $(e.target).closest('.drp-calendar').hasClass('left'),
          leftOrRight = isLeft ? 'left' : 'right',
          cal = this.container.find('.drp-calendar.'+leftOrRight);

        // Month must be Number for new moment versions
        var month = parseInt(cal.find('.monthselect').val(), 10);
        var year = cal.find('.yearselect').val();

        if (!isLeft) {
          if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
            month = this.startDate.month();
            year = this.startDate.year();
          }
        }

        if (this.minDate) {
          if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
            month = this.minDate.month();
            year = this.minDate.year();
          }
        }

        if (this.maxDate) {
          if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
            month = this.maxDate.month();
            year = this.maxDate.year();
          }
        }

        if (isLeft) {
          this.leftCalendar.month.month(month).year(year);
          if (this.linkedCalendars)
            this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
        } else {
          this.rightCalendar.month.month(month).year(year);
          if (this.linkedCalendars)
            this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
        }
        this.updateCalendars();
      },

      elementChanged: function() {
        if (!this.element.is('input')) return;
        if (!this.element.val().length) return;

        var dateString = this.element.val().split(this.locale.separator),
          start = null,
          end = null;

        if (dateString.length === 2) {
          start = moment(dateString[0], this.locale.format);
          end = moment(dateString[1], this.locale.format);
        }

        if (this.singleDatePicker || start === null || end === null) {
          start = moment(this.element.val(), this.locale.format);
          end = start;
        }

        if (!start.isValid() || !end.isValid()) return;

        this.setStartDate(start);
        this.setEndDate(end);
        this.updateView();
      },

      updateElement: function() {
        if (this.element.is('input') && this.autoUpdateInput) {
          var newValue = this.startDate.format(this.locale.format);
          if (!this.singleDatePicker) {
            newValue += this.locale.separator + this.endDate.format(this.locale.format);
          }
          if (newValue !== this.element.val()) {
            this.element.val(newValue).trigger('change');
          }
        }
      },

      remove: function() {
        this.container.remove();
        this.element.off('.daterangepicker');
        this.element.removeData();
      }

    };

    $.fn.daterangepicker = function(options, callback) {
      var implementOptions = $.extend(true, {}, $.fn.daterangepicker.defaultOptions, options);
      this.each(function() {
        var el = $(this);
        if (el.data('daterangepicker'))
          el.data('daterangepicker').remove();
        var drp = new DateRangePicker(el, implementOptions, callback);
        drp.show();
        el.data('daterangepicker', drp);
      });
      return this;
    };

    return DateRangePicker;

  }));
</script>
<% include ../../components/end.component.html %>
