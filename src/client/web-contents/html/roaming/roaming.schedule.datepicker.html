<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<meta name="format-detection" content="telephone=no" />
		<link rel="shortcut icon" href="/img/common/favicon.ico" />
		<link rel="shortcut icon" href="/img/common/favicon.png" />
		<link rel="apple-touch-icon" href="/img/common/favicon.png" />
		<meta name="description" content="T로밍 < 상품" />
		<meta name="keywords" content="T로밍 , 상품" />
		<meta property="og:title" content="초시대를 여는 T world" />
		<meta property="og:site_name" content="SKT" />
		<meta property="og:image" content="/img/dummy/kakao_share.jpg" />
		<meta property="og:description" content="T로밍 < 상품" />
		<title>T로밍 &lt; 상품</title>
		<link rel="stylesheet" type="text/css" href="/css/common.css" media="all" />
		<link rel="stylesheet" type="text/css" href="/css/layout.css" media="all" />
		<link rel="stylesheet" type="text/css" href="/css/widgets.css" media="all" />
		<link rel="stylesheet" type="text/css" href="/css/components.css" media="all" />
		<link rel="stylesheet" type="text/css" href="/css/roaming-next.css" media="all" />
		<script type="text/javascript" src="/lib/jquery-1.12.3.min.js"></script><!--[C] jquery API-->
        <script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script> 
		<script type="text/javascript" src="/lib/handlebars-v4.0.5.js"></script><!--[C] handlebars tmpl API-->
		<script type="text/javascript" src="/lib/slick.js"></script><!--[C] iscroll API -->
		<script type="text/javascript" src="/js/$vars.js"></script><!--[C] 전역 변수 -->
		<script type="text/javascript" src="/js/common.js"></script><!--[C] 공통 기능 -->
        <script type="text/javascript" src="/js/widgets.js"></script><!--[C] 기능별 위젯 -->
	</head>
	<body class="rn">
        <div id="scheduleDialog" class="dialog wrap" style="display: block">
            <!-- <input type="text" name="daterange" value="01/01/2018 - 01/15/2018" /> -->
			<div class="header">
				<img class="banner" width="100%" src="/img/product/roam/admin/schedule_banner.png" alt="" /><!-- //202011 - 웹접근성 수정건 적용 : alt="" 추가 -->
				<div class="summary">
					<h1><span id="target-nation" data-code="CHN">중국</span>, 언제 떠나세요?</h1>
					<div>
						<div class="date borderRight">
							<h2>가는 날</h2>
							<h3 id="date-depart">2020. 10. 12.(월)</h3>
						</div>
						<div class="date">
							<h2>오는 날</h2>
							<h3 id="date-arrive">-</h3>
						</div>
						<span></span>
					</div>
				</div>
				<!-- 202011 - 웹접근성 수정건 적용 : 기존 div를 a 로 변경 시작 -->
				<a href="#" role="button" class="close"> <img src="/img/product/roam/ico_close_w.svg" width="20" height="20" alt="닫기" /><!-- //202011 - 웹접근성 수정건 적용 : alt 수정 --> </a>
				<!-- //202011 - 웹접근성 수정건 적용 : 기존 div를 a 로 변경 끝 -->
			</div>
			<div id="scheduleContent">
				<div id="calendar"> 
				</div>
				<div class="bottom-space"></div>
				<div id="scheduleConfirm" class="bottom-button not-prepared">추천 요금제 확인</div>
			</div>
		</div>
	</body>
	
	<script> 
		(function (root, factory) {
			if (typeof define === "function" && define.amd) {
				// AMD. Make globaly available as well
				define(["moment", "jquery"], function (moment, jquery) {
					if (!jquery.fn) jquery.fn = {}; // webpack server rendering
					if (typeof moment !== "function" && moment.hasOwnProperty("default")) moment = moment["default"];
					return factory(moment, jquery);
				});
			} else if (typeof module === "object" && module.exports) {
				// Node / Browserify
				//isomorphic issue
				var jQuery = typeof window != "undefined" ? window.jQuery : undefined;
				if (!jQuery) {
					jQuery = require("jquery");
					if (!jQuery.fn) jQuery.fn = {};
				}
				var moment = typeof window != "undefined" && typeof window.moment != "undefined" ? window.moment : require("moment");
				module.exports = factory(moment, jQuery);
			} else {
				// Browser globals
				root.daterangepicker = factory(root.moment, root.jQuery);
			}
		})(typeof window !== "undefined" ? window : this, function (moment, $) {
			var DateRangePicker = function (element, options, cb) {
				//default settings for options
				this.parentEl = "body #scheduleDialog #scheduleContent #calendar"; //퍼블 파일에서 보기위해서 수정한것입니다. 이부분은 적용 제외 부탁 드립니다.
				this.element = $(element);
				this.startDate = moment().startOf("day");
				this.endDate = moment().endOf("day");
				this.minDate = false;
				this.maxDate = false;
				this.maxSpan = false;
				this.autoApply = false;
				this.singleDatePicker = false;
				this.minYear = moment().subtract(100, "year").format("YYYY");
				this.maxYear = moment().add(100, "year").format("YYYY");
				this.showWeekNumbers = false;
				this.showISOWeekNumbers = false;
				this.showCustomRangeLabel = true;
				this.linkedCalendars = true;
				this.autoUpdateInput = true;
				this.alwaysShowCalendars = false;
				this.ranges = {};

				this.opens = "right";
				if (this.element.hasClass("pull-right")) this.opens = "left";

				this.drops = "down";
				if (this.element.hasClass("dropup")) this.drops = "up";

				this.buttonClasses = "btn btn-sm";
				this.applyButtonClasses = "btn-primary";
				this.cancelButtonClasses = "btn-default";

				this.locale = {
					direction: "ltr",
					format: moment.localeData().longDateFormat("L"),
					separator: " - ",
					applyLabel: "Apply",
					cancelLabel: "Cancel",
					weekLabel: "W",
					customRangeLabel: "Custom Range",
					daysOfWeek: moment.weekdaysMin(),
					monthNames: moment.monthsShort(),
					firstDay: moment.localeData().firstDayOfWeek(),
				};

				this.callback = function () {};

				//some state information
				this.isShowing = false;
				this.leftCalendar = {};
				this.rightCalendar = {};

				//custom options from user
				if (typeof options !== "object" || options === null) options = {};

				//allow setting options with data attributes
				//data-api options will be overwritten with custom javascript options
				options = $.extend(this.element.data(), options);

				//html template for the picker UI
				if (typeof options.template !== "string" && !(options.template instanceof $)) options.template = '<div class="daterangepicker">' + '<div class="ranges"></div>' + '<div class="drp-calendar left">' + '<div class="calendar-table"></div>' + "</div>" + '<div class="drp-calendar right">' + '<div class="calendar-table"></div>' + "</div>" + "</div>";

				this.parentEl = options.parentEl && $(options.parentEl).length ? $(options.parentEl) : $(this.parentEl);
				this.container = $(options.template).appendTo(this.parentEl);

				//
				// handle all the possible options overriding defaults
				//

				this.container.addClass(this.locale.direction);

				if (typeof options.startDate === "string") this.startDate = moment(options.startDate, this.locale.format);

				if (typeof options.endDate === "string") this.endDate = moment(options.endDate, this.locale.format);

				if (typeof options.minDate === "string") this.minDate = moment(options.minDate, this.locale.format);

				if (typeof options.maxDate === "string") this.maxDate = moment(options.maxDate, this.locale.format);

				if (typeof options.startDate === "object") this.startDate = moment(options.startDate);

				if (typeof options.endDate === "object") this.endDate = moment(options.endDate);

				if (typeof options.minDate === "object") this.minDate = moment(options.minDate);

				if (typeof options.maxDate === "object") this.maxDate = moment(options.maxDate);

				// sanity check for bad options
				if (this.minDate && this.startDate.isBefore(this.minDate)) this.startDate = this.minDate.clone();

				// sanity check for bad options
				if (this.maxDate && this.endDate.isAfter(this.maxDate)) this.endDate = this.maxDate.clone();

				if (typeof options.applyButtonClasses === "string") this.applyButtonClasses = options.applyButtonClasses;

				if (typeof options.applyClass === "string")
					//backwards compat
					this.applyButtonClasses = options.applyClass;

				if (typeof options.cancelButtonClasses === "string") this.cancelButtonClasses = options.cancelButtonClasses;

				if (typeof options.cancelClass === "string")
					//backwards compat
					this.cancelButtonClasses = options.cancelClass;

				if (typeof options.maxSpan === "object") this.maxSpan = options.maxSpan;

				if (typeof options.dateLimit === "object")
					//backwards compat
					this.maxSpan = options.dateLimit;

				if (typeof options.opens === "string") this.opens = options.opens;

				if (typeof options.drops === "string") this.drops = options.drops;

				if (typeof options.showWeekNumbers === "boolean") this.showWeekNumbers = options.showWeekNumbers;

				if (typeof options.showISOWeekNumbers === "boolean") this.showISOWeekNumbers = options.showISOWeekNumbers;

				if (typeof options.buttonClasses === "string") this.buttonClasses = options.buttonClasses;

				if (typeof options.buttonClasses === "object") this.buttonClasses = options.buttonClasses.join(" ");

				if (typeof options.minYear === "number") this.minYear = options.minYear;

				if (typeof options.maxYear === "number") this.maxYear = options.maxYear;

				if (typeof options.showCustomRangeLabel === "boolean") this.showCustomRangeLabel = options.showCustomRangeLabel;

				if (typeof options.singleDatePicker === "boolean") {
					this.singleDatePicker = options.singleDatePicker;
					if (this.singleDatePicker) this.endDate = this.startDate.clone();
				}

				if (typeof options.autoApply === "boolean") this.autoApply = options.autoApply;

				if (typeof options.autoUpdateInput === "boolean") this.autoUpdateInput = options.autoUpdateInput;

				if (typeof options.linkedCalendars === "boolean") this.linkedCalendars = options.linkedCalendars;

				if (typeof options.isInvalidDate === "function") this.isInvalidDate = options.isInvalidDate;

				if (typeof options.isCustomDate === "function") this.isCustomDate = options.isCustomDate;

				if (typeof options.alwaysShowCalendars === "boolean") this.alwaysShowCalendars = options.alwaysShowCalendars;

				// update day names order to firstDay
				if (this.locale.firstDay != 0) {
					var iterator = this.locale.firstDay;
					while (iterator > 0) {
						this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
						iterator--;
					}
				}

				var start, end, range;

				//if no start/end dates set, check if an input element contains initial values
				if (typeof options.startDate === "undefined" && typeof options.endDate === "undefined") {
					if ($(this.element).is(":text")) {
						var val = $(this.element).val(),
							split = val.split(this.locale.separator);

						start = end = null;

						if (split.length == 2) {
							start = moment(split[0], this.locale.format);
							end = moment(split[1], this.locale.format);
						} else if (this.singleDatePicker && val !== "") {
							start = moment(val, this.locale.format);
							end = moment(val, this.locale.format);
						}
						if (start !== null && end !== null) {
							this.setStartDate(start);
							this.setEndDate(end);
						}
					}
				}

				if (typeof options.ranges === "object") {
					for (range in options.ranges) {
						if (typeof options.ranges[range][0] === "string") start = moment(options.ranges[range][0], this.locale.format);
						else start = moment(options.ranges[range][0]);

						if (typeof options.ranges[range][1] === "string") end = moment(options.ranges[range][1], this.locale.format);
						else end = moment(options.ranges[range][1]);

						// If the start or end date exceed those allowed by the minDate or maxSpan
						// options, shorten the range to the allowable period.
						if (this.minDate && start.isBefore(this.minDate)) start = this.minDate.clone();

						var maxDate = this.maxDate;
						if (this.maxSpan && maxDate && start.clone().add(this.maxSpan).isAfter(maxDate)) maxDate = start.clone().add(this.maxSpan);
						if (maxDate && end.isAfter(maxDate)) end = maxDate.clone();

						// If the end of the range is before the minimum or the start of the range is
						// after the maximum, don't display this range option at all.
						if ((this.minDate && end.isBefore(this.minDate, "day")) || (maxDate && start.isAfter(maxDate, "day"))) continue;

						//Support unicode chars in the range names.
						var elem = document.createElement("textarea");
						elem.innerHTML = range;
						var rangeHtml = elem.value;

						this.ranges[rangeHtml] = [start, end];
					}

					var list = "<ul>";
					for (range in this.ranges) {
						list += '<li data-range-key="' + range + '">' + range + "</li>";
					}
					if (this.showCustomRangeLabel) {
						list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + "</li>";
					}
					list += "</ul>";
					this.container.find(".ranges").prepend(list);
				}

				if (typeof cb === "function") {
					this.callback = cb;
				}

				this.startDate = this.startDate.startOf("day");
				this.endDate = this.endDate.endOf("day");

				if (this.autoApply) {
					this.container.addClass("auto-apply");
				}

				if (typeof options.ranges === "object") this.container.addClass("show-ranges");

				if (this.singleDatePicker) {
					this.container.addClass("single");
					this.container.find(".drp-calendar.left").addClass("single");
					this.container.find(".drp-calendar.left").show();
					this.container.find(".drp-calendar.right").hide();
					if (this.autoApply) {
						this.container.addClass("auto-apply");
					}
				}

				if ((typeof options.ranges === "undefined" && !this.singleDatePicker) || this.alwaysShowCalendars) {
					this.container.addClass("show-calendar");
				}

				this.container.addClass("opens" + this.opens);

				//apply CSS classes and labels to buttons
				this.container.find(".applyBtn, .cancelBtn").addClass(this.buttonClasses);
				if (this.applyButtonClasses.length) this.container.find(".applyBtn").addClass(this.applyButtonClasses);
				if (this.cancelButtonClasses.length) this.container.find(".cancelBtn").addClass(this.cancelButtonClasses);
				this.container.find(".applyBtn").html(this.locale.applyLabel);
				this.container.find(".cancelBtn").html(this.locale.cancelLabel);

				//
				// event listeners
				//

				this.container.find(".drp-calendar").on("click.daterangepicker", ".prev", $.proxy(this.clickPrev, this)).on("click.daterangepicker", ".next", $.proxy(this.clickNext, this)).on("mousedown.daterangepicker", "td.available", $.proxy(this.clickDate, this)).on("mouseenter.daterangepicker", "td.available", $.proxy(this.hoverDate, this)).on("change.daterangepicker", "select.yearselect", $.proxy(this.monthOrYearChanged, this)).on("change.daterangepicker", "select.monthselect", $.proxy(this.monthOrYearChanged, this));

				this.container.find(".ranges").on("click.daterangepicker", "li", $.proxy(this.clickRange, this));

				this.container.find(".drp-buttons").on("click.daterangepicker", "button.applyBtn", $.proxy(this.clickApply, this)).on("click.daterangepicker", "button.cancelBtn", $.proxy(this.clickCancel, this));

				if (this.element.is("input") || this.element.is("button")) {
					this.element.on({
						"click.daterangepicker": $.proxy(this.show, this),
						"focus.daterangepicker": $.proxy(this.show, this),
						"keyup.daterangepicker": $.proxy(this.elementChanged, this),
					});
				}
				//
				// if attached to a text input, set the initial value
				//

				this.updateElement();
			};

			DateRangePicker.prototype = {
				constructor: DateRangePicker,

				setStartDate: function (startDate) {
					if (typeof startDate === "string") this.startDate = moment(startDate, this.locale.format);

					if (typeof startDate === "object") this.startDate = moment(startDate);

					this.startDate = this.startDate.startOf("day");
					if (this.minDate && this.startDate.isBefore(this.minDate)) {
						this.startDate = this.minDate.clone();
					}
					if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
						this.startDate = this.maxDate.clone();
					}

					if (!this.isShowing) this.updateElement();

					this.updateMonthsInView();
				},

				setEndDate: function (endDate) {
					if (typeof endDate === "string") this.endDate = moment(endDate, this.locale.format);

					if (typeof endDate === "object") this.endDate = moment(endDate);

					this.endDate = this.endDate.endOf("day");
					if (this.endDate.isBefore(this.startDate)) this.endDate = this.startDate.clone();

					if (this.maxDate && this.endDate.isAfter(this.maxDate)) this.endDate = this.maxDate.clone();

					if (this.maxSpan && this.startDate.clone().add(this.maxSpan).isBefore(this.endDate)) this.endDate = this.startDate.clone().add(this.maxSpan);

					this.previousRightTime = this.endDate.clone();

					this.container.find(".drp-selected").html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));

					if (!this.isShowing) this.updateElement();

					this.updateMonthsInView();
				},

				isInvalidDate: function () {
					return false;
				},

				isCustomDate: function () {
					return false;
				},

				updateView: function () {
					if (this.endDate) this.container.find(".drp-selected").html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
					this.updateMonthsInView();
					this.updateCalendars();
					this.updateFormInputs();
				},

				updateMonthsInView: function () {
					if (this.endDate) {
						//if both dates are visible already, do nothing
						if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month && (this.startDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.startDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM")) && (this.endDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.endDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM"))) {
							return;
						}

						this.leftCalendar.month = this.startDate.clone().date(2);
						if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
							this.rightCalendar.month = this.endDate.clone().date(2);
						} else {
							this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month");
						}
					} else {
						if (this.leftCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM") && this.rightCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM")) {
							this.leftCalendar.month = this.startDate.clone().date(2);
							this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month");
						}
					}
					if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
						this.rightCalendar.month = this.maxDate.clone().date(2);
						this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, "month");
					}
				},

				updateCalendars: function () {
					this.renderCalendar("left");
					this.renderCalendar("right");

					//highlight any predefined range matching the current start and end dates
					this.container.find(".ranges li").removeClass("active");
					if (this.endDate == null) return;

					this.calculateChosenLabel();
				},

				renderCalendar: function (side) {
					//
					// Build the matrix of dates that will populate the calendar
					//

					var calendar = side == "left" ? this.leftCalendar : this.rightCalendar;
					var month = calendar.month.month();
					var year = calendar.month.year();
					var hour = calendar.month.hour();
					var minute = calendar.month.minute();
					var second = calendar.month.second();
					var daysInMonth = moment([year, month]).daysInMonth();
					var firstDay = moment([year, month, 1]);
					var lastDay = moment([year, month, daysInMonth]);
					var lastMonth = moment(firstDay).subtract(1, "month").month();
					var lastYear = moment(firstDay).subtract(1, "month").year();
					var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
					var dayOfWeek = firstDay.day();

					//initialize a 6 rows x 7 columns array for the calendar
					var calendar = [];
					calendar.firstDay = firstDay;
					calendar.lastDay = lastDay;

					for (var i = 0; i < 6; i++) {
						calendar[i] = [];
					}

					//populate the calendar with date objects
					var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
					if (startDay > daysInLastMonth) startDay -= 7;

					if (dayOfWeek == this.locale.firstDay) startDay = daysInLastMonth - 6;

					var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

					var col, row;
					for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, "hour")) {
						if (i > 0 && col % 7 === 0) {
							col = 0;
							row++;
						}
						calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
						curDate.hour(12);

						if (this.minDate && calendar[row][col].format("YYYY-MM-DD") == this.minDate.format("YYYY-MM-DD") && calendar[row][col].isBefore(this.minDate) && side == "left") {
							calendar[row][col] = this.minDate.clone();
						}

						if (this.maxDate && calendar[row][col].format("YYYY-MM-DD") == this.maxDate.format("YYYY-MM-DD") && calendar[row][col].isAfter(this.maxDate) && side == "right") {
							calendar[row][col] = this.maxDate.clone();
						}
					}

					//make the calendar object available to hoverDate/clickDate
					if (side == "left") {
						this.leftCalendar.calendar = calendar;
					} else {
						this.rightCalendar.calendar = calendar;
					}

					//
					// Display the calendar
					//
					var datePickerTabidx = 0; //202011 - 웹접근성 수정건 적용 : 디폴트 탭 인덱스 0 적용
					var minDate = side == "left" ? this.minDate : this.startDate;
					var maxDate = this.maxDate;
					var selected = side == "left" ? this.startDate : this.endDate;
					var arrow = this.locale.direction == "ltr" ? { left: "chevron-left", right: "chevron-right" } : { left: "chevron-right", right: "chevron-left" };
					var dateHtml = calendar[1][1].format("YYYY") + "년 " + this.locale.monthNames[calendar[1][1].month()]; // 202011 - 웹접근성 수정건 적용 : 위치 위로 옮김
					
				// 202011 - 웹접근성 수정건 적용 : datePickerTableHeader 추가 시작
					var datePickerTableHeader = '<div class="table-condensed-header">';
					
					// 이전달 다음달 버튼, 월 영역 테이블 에서 따로 분리함 
					datePickerTableHeader += '<h3 class="table-condensed-title">' + dateHtml + "</h3>";
					if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == "left")) {
						datePickerTableHeader += '<div class="table-condensed-header__btns prev available"><button type="button" title="이전달 이동"><span></span></button></div>'; 
					}
				
					if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == "right" || this.singleDatePicker)) {
						datePickerTableHeader += '<div class="table-condensed-header__btns next available"><button type="button" title="다음달 이동"><span></span></button></div>'; 
					}
					//
					datePickerTableHeader +="</div>";
				// 202011 - 웹접근성 수정건 적용 : datePickerTableHeader 추가 끝
					var html = '<table class="table-condensed">';
					html += '<caption>' + dateHtml + " 달력 정보 입니다" + '</caption>'; // 202011 - 웹접근성 수정건 적용 : caption 추가
					html += "<thead>";
				// 202011 - 웹접근성 수정건 적용 : thead 불필요정보 삭제 시작 		
					// html += "<tr>";

					// add empty cell for week number - 이부분은 삭제해도 되는 부분인지 개발팀에서 확인부탁드립니다.
					// if (this.showWeekNumbers || this.showISOWeekNumbers) html += "<th></th>";

				
					// if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == "left")) {
					//     html += '<th class="prev available"><button type="button" title="이전달"><span></span></button></th>'; 
					//     html += "<th></th>";
					// }

					// html += '<th colspan="5" class="month">' + dateHtml + "</th>";
					// if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == "right" || this.singleDatePicker)) {
					//     html += '<th class="next available"><button type="button" title="다음달"><span></span></button></th>'; 
					// } else {
					//     html += "<th></th>";
					// }
				
					// html += "</tr>";
				// 202011 - 웹접근성 수정건 적용 : thead 불필요정보 삭제 끝 
					html += "<tr>";

					// add week number label
					if (this.showWeekNumbers || this.showISOWeekNumbers) html += '<th class="week">' + this.locale.weekLabel + "</th>";

					$.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
						html += '<th scope="col">' + dayOfWeek + '</th>'; // 202011 - 웹접근성 수정건 적용 : sope="col" 추가
					});

					html += "</tr>";
					html += "</thead>";
					html += "<tbody>";

					//adjust maxDate to reflect the maxSpan setting in order to
					//grey out end dates beyond the maxSpan
					if (this.endDate == null && this.maxSpan) {
						var maxLimit = this.startDate.clone().add(this.maxSpan).endOf("day");
						if (!maxDate || maxLimit.isBefore(maxDate)) {
							maxDate = maxLimit;
						}
					}

					for (var row = 0; row < 6; row++) {
						html += "<tr>";

						// add week number
						if (this.showWeekNumbers) html += '<td class="week">' + calendar[row][0].week() + "</td>";
						else if (this.showISOWeekNumbers) html += '<td class="week">' + calendar[row][0].isoWeek() + "</td>";

						for (var col = 0; col < 7; col++) {
							var classes = [];

							//highlight today's date
							if (calendar[row][col].isSame(new Date(), "day")) classes.push("today");

							//highlight weekends
							if (calendar[row][col].isoWeekday() > 5) classes.push("weekend");

							//grey out the dates in other months displayed at beginning and end of this calendar
							if (calendar[row][col].month() != calendar[1][1].month()) classes.push("off", "ends");

							//don't allow selection of dates before the minimum date
							if (this.minDate && calendar[row][col].isBefore(this.minDate, "day")) classes.push("off", "disabled");

							//don't allow selection of dates after the maximum date
							if (maxDate && calendar[row][col].isAfter(maxDate, "day")) classes.push("off", "disabled");

							//don't allow selection of date if a custom function decides it's invalid
							if (this.isInvalidDate(calendar[row][col])) classes.push("off", "disabled");

							//highlight the currently selected start date
							if (calendar[row][col].format("YYYY-MM-DD") == this.startDate.format("YYYY-MM-DD")) classes.push("active", "start-date");

							//highlight the currently selected end date
							if (this.endDate != null && calendar[row][col].format("YYYY-MM-DD") == this.endDate.format("YYYY-MM-DD")) classes.push("active", "end-date");

							//highlight dates in-between the selected dates
							if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate) classes.push("in-range");

							//apply custom classes for this date
							var isCustom = this.isCustomDate(calendar[row][col]);
							if (isCustom !== false) {
								if (typeof isCustom === "string") classes.push(isCustom);
								else Array.prototype.push.apply(classes, isCustom);
							}

							var cname = "",
								disabled = false;
							for (var i = 0; i < classes.length; i++) {
								cname += classes[i] + " ";
								if (classes[i] == "disabled") disabled = true;
							}
							if (!disabled) cname += "available";

							html += '<td class="' + cname.replace(/^\s+|\s+$/g, "") + '" data-title="' + "r" + row + "c" + col + '"  role="button" tabindex="'+ datePickerTabidx +'"    >' + calendar[row][col].date() + "</td>";  // 202011 - 웹접근성 수정건 적용 : role="button" , tabindex 추가
						}
						html += "</tr>";
					}

					html += "</tbody>";
					html += "</table>";
					this.container.find(".drp-calendar." + side + " .calendar-table").html(html);
					this.container.find(".drp-calendar." + side + " .calendar-table .table-condensed").before(datePickerTableHeader);  // 202011 - 웹접근성 수정건 적용 : .table-condensed-header 추가
				},

				updateFormInputs: function () {
					if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
						this.container.find("button.applyBtn").prop("disabled", false);
					} else {
						this.container.find("button.applyBtn").prop("disabled", true);
					}
				},

				move: function () {
					var parentOffset = { top: 0, left: 0 },
						containerTop,
						drops = this.drops;

					var parentRightEdge = $(window).width();
					if (!this.parentEl.is("body")) {
						parentOffset = {
							top: this.parentEl.offset().top - this.parentEl.scrollTop(),
							left: this.parentEl.offset().left - this.parentEl.scrollLeft(),
						};
						parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
					}

					switch (drops) {
						case "auto":
							containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
							if (containerTop + this.container.outerHeight() >= this.parentEl[0].scrollHeight) {
								containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
								drops = "up";
							}
							break;
						case "up":
							containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
							break;
						default:
							containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
							break;
					}

					// Force the container to it's actual width
					this.container.css({
						top: 0,
						left: 0,
						right: "auto",
					});
					var containerWidth = this.container.outerWidth();

					this.container.toggleClass("drop-up", drops == "up");

					if (this.opens == "left") {
						var containerRight = parentRightEdge - this.element.offset().left - this.element.outerWidth();
						if (containerWidth + containerRight > $(window).width()) {
							this.container.css({
								top: containerTop,
								right: "auto",
								left: 9,
							});
						} else {
							this.container.css({
								top: containerTop,
								right: containerRight,
								left: "auto",
							});
						}
					} else if (this.opens == "center") {
						var containerLeft = this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2 - containerWidth / 2;
						if (containerLeft < 0) {
							this.container.css({
								top: containerTop,
								right: "auto",
								left: 9,
							});
						} else if (containerLeft + containerWidth > $(window).width()) {
							this.container.css({
								top: containerTop,
								left: "auto",
								right: 0,
							});
						} else {
							this.container.css({
								top: containerTop,
								left: containerLeft,
								right: "auto",
							});
						}
					} else {
						var containerLeft = this.element.offset().left - parentOffset.left;
						if (containerLeft + containerWidth > $(window).width()) {
							this.container.css({
								top: containerTop,
								left: "auto",
								right: 0,
							});
						} else {
							this.container.css({
								top: containerTop,
								left: containerLeft,
								right: "auto",
							});
						}
					}
				},

				show: function (e) {
					if (this.isShowing) return;

					// Reposition the picker if the window is resized while it's open
					$(window).on(
						"resize.daterangepicker",
						$.proxy(function (e) {
							this.move(e);
						}, this)
					);

					this.oldStartDate = this.startDate.clone();
					this.oldEndDate = this.endDate.clone();
					this.previousRightTime = this.endDate.clone();

					this.updateView();
					this.container.show();
					this.move();
					this.element.trigger("show.daterangepicker", this);
					this.isShowing = true;
				},

				hide: function (e) {
					throw new Error("*hide*");
					if (!this.isShowing) return;

					//incomplete date selection, revert to last values
					if (!this.endDate) {
						this.startDate = this.oldStartDate.clone();
						this.endDate = this.oldEndDate.clone();
					}

					//if a new date range was selected, invoke the user callback function
					if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate)) this.callback(this.startDate.clone(), this.endDate.clone(), this.chosenLabel);

					//if picker is attached to a text input, update it
					this.updateElement();

					$(document).off(".daterangepicker");
					$(window).off(".daterangepicker");
					this.container.hide();
					this.element.trigger("hide.daterangepicker", this);
					this.isShowing = false;
				},

				showCalendars: function () {
					this.container.addClass("show-calendar");
					this.move();
					this.element.trigger("showCalendar.daterangepicker", this);
				},

				hideCalendars: function () {
					this.container.removeClass("show-calendar");
					this.element.trigger("hideCalendar.daterangepicker", this);
				},

				clickRange: function (e) {
					var label = e.target.getAttribute("data-range-key");
					this.chosenLabel = label;
					if (label == this.locale.customRangeLabel) {
						this.showCalendars();
					} else {
						var dates = this.ranges[label];
						this.startDate = dates[0];
						this.endDate = dates[1];

						this.startDate.startOf("day");
						this.endDate.endOf("day");

						if (!this.alwaysShowCalendars) this.hideCalendars();
						this.clickApply();
					}
				},

				clickPrev: function (e) {
					var cal = $(e.target).parents(".drp-calendar");
					if (cal.hasClass("left")) {
						this.leftCalendar.month.subtract(1, "month");
						if (this.linkedCalendars) this.rightCalendar.month.subtract(1, "month");
					} else {
						this.rightCalendar.month.subtract(1, "month");
					}
					this.updateCalendars();
				},

				clickNext: function (e) {
					var cal = $(e.target).parents(".drp-calendar");
					if (cal.hasClass("left")) {
						this.leftCalendar.month.add(1, "month");
					} else {
						this.rightCalendar.month.add(1, "month");
						if (this.linkedCalendars) this.leftCalendar.month.add(1, "month");
					}
					this.updateCalendars();
				},

				hoverDate: function (e) {
					//ignore dates that can't be selected
					if (!$(e.target).hasClass("available")) return;

					var title = $(e.target).attr("data-title");
					var row = title.substr(1, 1);
					var col = title.substr(3, 1);
					var cal = $(e.target).parents(".drp-calendar");
					var date = cal.hasClass("left") ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

					//highlight the dates between the start date and the date being hovered as a potential end date
					var leftCalendar = this.leftCalendar;
					var rightCalendar = this.rightCalendar;
					var startDate = this.startDate;
					if (!this.endDate) {
						this.container.find(".drp-calendar tbody td").each(function (index, el) {
							//skip week numbers, only look at dates
							if ($(el).hasClass("week")) return;

							var title = $(el).attr("data-title");
							var row = title.substr(1, 1);
							var col = title.substr(3, 1);
							var cal = $(el).parents(".drp-calendar");
							var dt = cal.hasClass("left") ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

							if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, "day")) {
								$(el).addClass("in-range");
							} else {
								$(el).removeClass("in-range");
							}
						});
					}
				},

				clickDate: function (e) {
					if (!$(e.target).hasClass("available")) return;

					var title = $(e.target).attr("data-title");
					var row = title.substr(1, 1);
					var col = title.substr(3, 1);
					var cal = $(e.target).parents(".drp-calendar");
					var date = cal.hasClass("left") ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

					//
					// this function needs to do a few things:
					// * alternate between selecting a start and end date for the range,
					// * if autoapply is enabled, and an end date was chosen, apply the selection
					// * if single date picker mode, apply the selection immediately
					// * if one of the inputs above the calendars was focused, cancel that manual input
					//

					if (this.endDate || date.isBefore(this.startDate, "day")) {
						//picking start
						this.endDate = null;
						this.setStartDate(date.clone());
						this.callback(date.clone(), null);
					} else if (!this.endDate && date.isBefore(this.startDate)) {
						this.setEndDate(this.startDate.clone());
					} else {
						// picking end
						this.setEndDate(date.clone());
						this.callback(this.startDate.clone(), date.clone());
					}

					this.updateView();
					e.stopPropagation();
				},

				calculateChosenLabel: function () {
					var customRange = true;
					var i = 0;
					for (var range in this.ranges) {
						if (this.startDate.format("YYYY-MM-DD") == this.ranges[range][0].format("YYYY-MM-DD") && this.endDate.format("YYYY-MM-DD") == this.ranges[range][1].format("YYYY-MM-DD")) {
							customRange = false;
							this.chosenLabel = this.container
								.find(".ranges li:eq(" + i + ")")
								.addClass("active")
								.attr("data-range-key");
							break;
						}
						i++;
					}
					if (customRange) {
						if (this.showCustomRangeLabel) {
							this.chosenLabel = this.container.find(".ranges li:last").addClass("active").attr("data-range-key");
						} else {
							this.chosenLabel = null;
						}
						this.showCalendars();
					}
				},

				clickApply: function (e) {
					this.hide();
					this.element.trigger("apply.daterangepicker", this);
				},

				clickCancel: function (e) {
					this.startDate = this.oldStartDate;
					this.endDate = this.oldEndDate;
					this.hide();
					this.element.trigger("cancel.daterangepicker", this);
				},

				monthOrYearChanged: function (e) {
					var isLeft = $(e.target).closest(".drp-calendar").hasClass("left"),
						leftOrRight = isLeft ? "left" : "right",
						cal = this.container.find(".drp-calendar." + leftOrRight);

					// Month must be Number for new moment versions
					var month = parseInt(cal.find(".monthselect").val(), 10);
					var year = cal.find(".yearselect").val();

					if (!isLeft) {
						if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
							month = this.startDate.month();
							year = this.startDate.year();
						}
					}

					if (this.minDate) {
						if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
							month = this.minDate.month();
							year = this.minDate.year();
						}
					}

					if (this.maxDate) {
						if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
							month = this.maxDate.month();
							year = this.maxDate.year();
						}
					}

					if (isLeft) {
						this.leftCalendar.month.month(month).year(year);
						if (this.linkedCalendars) this.rightCalendar.month = this.leftCalendar.month.clone().add(1, "month");
					} else {
						this.rightCalendar.month.month(month).year(year);
						if (this.linkedCalendars) this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, "month");
					}
					this.updateCalendars();
				},

				elementChanged: function () {
					if (!this.element.is("input")) return;
					if (!this.element.val().length) return;

					var dateString = this.element.val().split(this.locale.separator),
						start = null,
						end = null;

					if (dateString.length === 2) {
						start = moment(dateString[0], this.locale.format);
						end = moment(dateString[1], this.locale.format);
					}

					if (this.singleDatePicker || start === null || end === null) {
						start = moment(this.element.val(), this.locale.format);
						end = start;
					}

					if (!start.isValid() || !end.isValid()) return;

					this.setStartDate(start);
					this.setEndDate(end);
					this.updateView();
				},

				updateElement: function () {
					if (this.element.is("input") && this.autoUpdateInput) {
						var newValue = this.startDate.format(this.locale.format);
						if (!this.singleDatePicker) {
							newValue += this.locale.separator + this.endDate.format(this.locale.format);
						}
						if (newValue !== this.element.val()) {
							this.element.val(newValue).trigger("change");
						}
					}
				},

				remove: function () {
					this.container.remove();
					this.element.off(".daterangepicker");
					this.element.removeData();
				},
			};

			$.fn.daterangepicker = function (options, callback) {
				var implementOptions = $.extend(true, {}, $.fn.daterangepicker.defaultOptions, options);
				this.each(function () {
					var el = $(this);
					if (el.data("daterangepicker")) el.data("daterangepicker").remove();
					var drp = new DateRangePicker(el, implementOptions, callback);
					drp.show();
					el.data("daterangepicker", drp);
				});
				return this;
			};

			return DateRangePicker;
		});


		$(function() { 
			$('#calendar').daterangepicker({ }); 
		}); 
	
	</script> 
        
</html>
